<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>Eric Hederstedt</title>
    <link href="https://onkeldolf.github.io/portfolio/feed.xml" rel="self" />
    <link href="https://onkeldolf.github.io/portfolio" />
    <updated>2024-04-03T19:58:00+02:00</updated>
    <author>
        <name>Eric Hederstedt</name>
    </author>
    <id>https://onkeldolf.github.io/portfolio</id>

    <entry>
        <title>Global Illumination</title>
        <author>
            <name>Eric Hederstedt</name>
        </author>
        <link href="https://onkeldolf.github.io/portfolio/global-illumination.html"/>
        <id>https://onkeldolf.github.io/portfolio/global-illumination.html</id>
        <media:content url="https://onkeldolf.github.io/portfolio/media/posts/7/Launcher_Debug_xnfl0cFPxK.png" medium="image" />

        <updated>2024-04-03T19:58:00+02:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://onkeldolf.github.io/portfolio/media/posts/7/Launcher_Debug_xnfl0cFPxK.png" alt="" />
                    Overview The main goal of this project was to improve the lighting quality in our game engine by adding a source of indirect global illumination. Realistic lighting is a crucial aspect of creating immersive and visually appealing virtual environments, and global illumination (GI) plays a&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://onkeldolf.github.io/portfolio/media/posts/7/Launcher_Debug_xnfl0cFPxK.png" class="type:primaryImage" alt="" /></p>
                
    <h2 id="overview">
      Overview
    </h2>

  <p>
    The main goal of this project was to improve the lighting quality in our game engine by adding a source of indirect global illumination. Realistic lighting is a crucial aspect of creating immersive and visually appealing virtual environments, and global illumination (GI) plays a significant role in achieving this. GI simulates the way light bounces and reflects off surfaces, creating indirect lighting effects that contribute to the overall realism and atmosphere of a scene.<br><br>The GI method I chose to implement was grid-placed light probes containing order 3 spherical harmonic coefficients. This approach is a classic and practical way of approximating global illumination, as it strikes a balance between visual quality and performance. Light probes are strategically placed throughout the scene, capturing and encoding the incident lighting information using spherical harmonics, a mathematical representation that allows for efficient storage and interpolation of lighting data.<br><br>By incorporating this technique into our engine, we aimed to enhance the visual fidelity of our scenes, creating more realistic and natural-looking lighting conditions that better mimic the behavior of light in the real world.
  </p>

    <h2 id="result">
      Result
    </h2>

  <p>
    Here is a showcase of some test scenes, with and without global illumination enabled:
  </p>

  <div  class="gallery-wrapper">
    <div class="gallery" data-columns="3">
      <figure class="gallery__item">
      <a href="https://onkeldolf.github.io/portfolio/media/posts/7/gallery/Launcher_Debug_fmCYlmRabl.png" data-size="1920x1080">
        <img loading="lazy" src="https://onkeldolf.github.io/portfolio/media/posts/7/gallery/Launcher_Debug_fmCYlmRabl-thumbnail.png" height="405" width="720" alt="" >
      </a>
      <figcaption>Without Global Illumination</figcaption>
    </figure><figure class="gallery__item">
      <a href="https://onkeldolf.github.io/portfolio/media/posts/7/gallery/Launcher_Debug_xnfl0cFPxK.png" data-size="1920x1080">
        <img loading="lazy" src="https://onkeldolf.github.io/portfolio/media/posts/7/gallery/Launcher_Debug_xnfl0cFPxK-thumbnail.png" height="405" width="720" alt="" >
      </a>
      <figcaption>With Global Illumination</figcaption>
    </figure>
    </div>
  </div>

  <p>
    In this Cornell box scene, the impact of global illumination is clearly visible. Without GI, the objects appear flat and lack the color bleeding effects that occur when light bounces off colored surfaces. With GI enabled, the red and green walls cast a tint on the nearby objects, creating a more realistic and visually pleasing result. The added indirect lighting helps to soften shadows and enhance the overall sense of depth and dimensionality in the scene.
  </p>

  <div  class="gallery-wrapper">
    <div class="gallery" data-columns="3">
      <figure class="gallery__item">
      <a href="https://onkeldolf.github.io/portfolio/media/posts/7/gallery/Launcher_Release_Py3kZ9cTs9.png" data-size="1920x1080">
        <img loading="lazy" src="https://onkeldolf.github.io/portfolio/media/posts/7/gallery/Launcher_Release_Py3kZ9cTs9-thumbnail.png" height="405" width="720" alt="" >
      </a>
      <figcaption>Without Global Illumination</figcaption>
    </figure><figure class="gallery__item">
      <a href="https://onkeldolf.github.io/portfolio/media/posts/7/gallery/Launcher_Release_9PWQC6W7yq.png" data-size="1920x1080">
        <img loading="lazy" src="https://onkeldolf.github.io/portfolio/media/posts/7/gallery/Launcher_Release_9PWQC6W7yq-thumbnail.png" height="405" width="720" alt="" >
      </a>
      <figcaption>With Global Illumination</figcaption>
    </figure>
    </div>
  </div>

  <p>
    The box scene with a top opening demonstrates the importance of indirect lighting in enclosed environments. Without GI, only the areas directly exposed to the light source are illuminated, leaving the rest of the interior in complete darkness. With GI enabled, the light entering through the opening bounces off the interior surfaces, spreading illumination to areas that are not in direct line of sight of the light source. This creates a more realistic and natural-looking result, as it mimics how light behaves in real-world enclosed spaces, enhancing the overall sense of depth and realism in the scene.
  </p>

  <p>
    Performance-wise, this method of implementing global illumination is relatively cheap in terms of runtime overhead, as the precomputed lighting data can be efficiently accessed and interpolated during rendering.
  </p>

    <h2 id="technical-implementation">
      Technical Implementation
    </h2>

  <p>
    The process of baking a light probe could be broken down into a 3 step process:
  </p>

  <ul>
    <li>Render the scene into a cube map as our radiance map.</li><li>Convert the radiance map to a irradiance map.</li><li>Project the irradiance map into spherical harmonic values.</li>
  </ul>

  <p>
    In total I ended up with this function:
  </p>
<pre class="line-numbers  language-cpp"><code>void Light_Probe_Manager::update_probe(int index, std::function&lt;void(Cube_Map_Render_Target*)&gt; render_func)
{
	Light_Probe& light_probe = light_probes[index];

	cube_map_radiance_target.SetPosition(light_probe.position);

	render_func(&cube_map_radiance_target);

	CubeMapRenderTarget* cube_map = &cube_map_radiance_target;
#if ENABLE_IRRADIANCE
	convert_radiance_to_irradiance_map(&cube_map_radiance_target, &cube_map_irradiance_target);
	cube_map = &cube_map_irradiance_target;
#endif

	float r[9] = {};
	float g[9] = {};
	float b[9] = {};
 	project_cube_map_to_sh(r, g, b, cube_map);

	memcpy(light_probe.r, r, sizeof(r));
	memcpy(light_probe.g, g, sizeof(g));
	memcpy(light_probe.b, b, sizeof(b));
}</code></pre>

  <p>
    Then to use this in a pixel shader I sample the 8 closest light probes and tri-linearly interpolate in between them to get smooth transitions between light probes.
  </p>

  <p>
    I ended up with this as my sampling code:
  </p>
<pre class="line-numbers  language-cpp"><code>float3 color[8];
for (int i = 0; i &lt; 8; i++)
{
    Light_Probe probe = light_probe_buffer[indices[i]];

    float basis[9];
    sh_eval_basis_2(dir, basis);

    color[i].r = sh_dot_order3(basis, probe.r);
    color[i].g = sh_dot_order3(basis, probe.g);
    color[i].b = sh_dot_order3(basis, probe.b);
}</code></pre>

  <p>
    An example of non-interpolated and interpolated:
  </p>

  <div  class="gallery-wrapper">
    <div class="gallery" data-columns="3">
      <figure class="gallery__item">
      <a href="https://onkeldolf.github.io/portfolio/media/posts/7/gallery/Launcher_Release_J6ragZoAaM.png" data-size="1920x1080">
        <img loading="lazy" src="https://onkeldolf.github.io/portfolio/media/posts/7/gallery/Launcher_Release_J6ragZoAaM-thumbnail.png" height="405" width="720" alt="" >
      </a>
      <figcaption>Without interpolation</figcaption>
    </figure><figure class="gallery__item">
      <a href="https://onkeldolf.github.io/portfolio/media/posts/7/gallery/Launcher_Release_kwRUAeCbTF-2.png" data-size="1920x1080">
        <img loading="lazy" src="https://onkeldolf.github.io/portfolio/media/posts/7/gallery/Launcher_Release_kwRUAeCbTF-2-thumbnail.png" height="405" width="720" alt="" >
      </a>
      <figcaption>With interpolation</figcaption>
    </figure>
    </div>
  </div>
<pre class="line-numbers  language-cpp"><code>// Tri-linear interpolation
float back_to_front_weight = (position_ws.z - min_bounds.z) / (max_bounds.z - min_bounds.z);
float bottom_to_top_weight = (position_ws.y - min_bounds.y) / (max_bounds.y - min_bounds.y);
float left_to_right_weight = (position_ws.x - min_bounds.x) / (max_bounds.x - min_bounds.x);

float3 color_0 = lerp(color[0], color[1], left_to_right_weight);
float3 color_1 = lerp(color[2], color[3], left_to_right_weight);
float3 color_2 = lerp(color[4], color[5], left_to_right_weight);
float3 color_3 = lerp(color[6], color[7], left_to_right_weight);

float3 color_4 = lerp(color_0, color_1, bottom_to_top_weight);
float3 color_5 = lerp(color_2, color_3, bottom_to_top_weight);

return lerp(color_4, color_5, back_to_front_weight);</code></pre>

  <p>
    
  </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>About</title>
        <author>
            <name>Eric Hederstedt</name>
        </author>
        <link href="https://onkeldolf.github.io/portfolio/about.html"/>
        <id>https://onkeldolf.github.io/portfolio/about.html</id>

        <updated>2024-04-03T09:44:54+02:00</updated>
            <summary>
                <![CDATA[
                    My name is Eric Hederstedt, and I am a passionate programming student at The Game Assembly, pursuing a career in rendering engineering. I have been programming on and off since I was 13, working on my own game engine since the age of 17. Additionally,&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                
  <p>
    My name is Eric Hederstedt, and I am a passionate programming student at The Game Assembly, pursuing a career in rendering engineering. I have been programming on and off since I was 13, working on my own game engine since the age of 17. Additionally, I have been an active member of the Arma 3 modding community, primarily as a scripting and config modder, with one of my mods having a total of 14,000 active subscribers.
<br>
<br>What drew me to the field of game development, and specifically rendering engineering, was the challenge it presents. Game programming combines the difficulties faced by various other industries, such as handling massive amounts of data, rendering incredible worlds, and building secure and safe systems, all while ensuring high performance and speed. This is why I chose to specialize in rendering engineering – I have always enjoyed working with low-level APIs and building performant software, and graphics programming is a sub-discipline that aligns perfectly with these interests.
<br>
<br>So far, I have particularly enjoyed working with APIs and building rendering systems. Currently, I am leading my team's efforts in developing our next renderer using DirectX 12. However, I also find great satisfaction in implementing rendering techniques, such as ray-marched volumetric lighting or light probe-based static global illumination with spherical harmonics.
  </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>TGA Project 7: “Streamer attacked by ALIENS”</title>
        <author>
            <name>Eric Hederstedt</name>
        </author>
        <link href="https://onkeldolf.github.io/portfolio/tga-project-7-streamer-attacked-by-aliens.html"/>
        <id>https://onkeldolf.github.io/portfolio/tga-project-7-streamer-attacked-by-aliens.html</id>

        <updated>2024-03-20T18:18:30+01:00</updated>
            <summary></summary>
        <content></content>
    </entry>
    <entry>
        <title>TGA Project 6: “Spite: String of Fate”</title>
        <author>
            <name>Eric Hederstedt</name>
        </author>
        <link href="https://onkeldolf.github.io/portfolio/tga-project-6-spite-string-of-fate.html"/>
        <id>https://onkeldolf.github.io/portfolio/tga-project-6-spite-string-of-fate.html</id>

        <updated>2024-03-20T18:18:27+01:00</updated>
            <summary></summary>
        <content></content>
    </entry>
    <entry>
        <title>TGA Project 5: “Лаборатория (The Laboratory)”</title>
        <author>
            <name>Eric Hederstedt</name>
        </author>
        <link href="https://onkeldolf.github.io/portfolio/tga-project-5-laboratoriya-the-laboratory.html"/>
        <id>https://onkeldolf.github.io/portfolio/tga-project-5-laboratoriya-the-laboratory.html</id>

        <updated>2024-03-20T18:18:10+01:00</updated>
            <summary>
                <![CDATA[
                    In this project ...
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>In this project ...</p>
            ]]>
        </content>
    </entry>
</feed>
